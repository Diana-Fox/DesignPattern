# 模板方法模式

```
定义：
    定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
    模板方法是的子类可以不改变一个算法的结果即可重新定义该算法的某些特点步骤。

模板方法模式：
    模式的功能在于固定算法骨架，而让具体算法实现可以扩展。
    在设计框架级功能的时候非常有用。框架定义好了算法的步骤，在合适的点人开发人员进行扩展，实现具体的算法。
    模板方法还额外提供了一个好处，就是可以控制子类的扩展。
    因为在父类中定义好了算法的步骤，只是在某几个固定的点才会调用到被子类实现的方法，因此也就只允许在这几个点来扩展功能，
    这些个可以被子类覆盖以扩展功能的方法通常被称为“钩子”方法。
    
为何不是接口，而是抽象类：
    既要约束子类的行为，又要为子类提供公共功能的时候使用抽象类。
    模板方法模式，需要固定定义算法骨架，骨架方法应该只有一份，骨架方法是公共行为的，但实现各不相同，所以符合抽象类原则。
    
分析程序中哪些功能是可变的，哪些功能是不变的，把不变的部分抽象出来，进行公共的实现，把变化的部分分离出去，用接口来封装隔离，或用抽象类来约束子类行为。

好莱坞法则：由父类找子类，而不是子类找父类。
    这是一种反向控制结构，通常思路子类调用父类的方法，因为父类根本不知道子类，而子类知道父类，但是在模板方法模式里面，是父类来找子类，所以是一种反向控制。
    
Java能实现的理论依据是动态绑定采用的是“后期绑定”技术，对于出现子类覆盖父类方法的情况，在编译时是看数据类型，运行时看实际的对象类型。
    即new谁就调用谁的方法。

模板的写法：
    通常在模板里包含如下操作类型：
    1、模板方法：就是定义算法骨架的方法
    2、具体的操作：在模板中直接实现某些步骤的方法，通常这些步骤的实现算法是固定的，而且是不怎么变化的，因此就可以当作公共功能实现在模板里面。
    如果不需提供给子类访问这些方法的话，还可以是private的。这样一来，子类需要访问，可以把这些方法定义为protected final的，因为通常情况下，这些实现不能够被子类覆盖和改变。
    3、具体的AbstractClass操作：在模板中实现某些公共功能，可以提供给子类使用，一般不是具体的算法步骤的实现，只是一些辅助的公共功能。
    4、原语操作：在模板方法中定义的抽象操作，通常是模板方法需要调用的操作，是必需的操作，而且在父类中还没有办法确定下来如何实现，需要子类来真正实现的方法。
    5、钩子操作：在模板中定义。并提供默认实现的操作。这些方法通常被视为可扩展的点，但不是必须的，子类可以有选择的覆盖这些方法，以提供新的实现来扩展功能。
    6、Factory Method：在模板方法中，如果需要得到某些对象实例的话，可以考虑通过工厂方法模式来获取，把具体的构建对象的实现延迟到子类中去。

Java回调与模板方法模式
    模板方法模式的一个目的，就在于让其他类来扩展或具体实现在模板中固定的算法骨架中的某些算法步骤。
    在标准的模板方法模式实现中，主要是使用继承的方式，来让父类在运行期间可用调用到子类的方法。
    其实在Java开发中，还有另外一个方法可以实现同样的效果或是功能，
    就是——Java回调技术，通过回调在接口中定义的方法，调用到具体的实现类中的方法，其本质同样是利用Java的动态绑定技术，
    在这种实现中，可以不把实现类写成单独的类，而是使用匿名内部类来实现回调方法。
    
 两种实现方式的比较：
    1、使用继承的方式，抽象方法和具体实现的关系，是在编译期静态决定的，是类级关系。使用Java回调，这个关系是在运行期间动态决定的，是对象级的关系。
    2、相对而言，使用回调机制会更灵活，因为Java是单继承的，如果使用继承的方式，对于子类而言，今后就不能继承其他对象了，而使用回调，是基于接口的。
    另一方面，回调机制的是通过委托的方式来组合功能，它的耦合强度比继承低一些，这会给我们更多的灵活性。
    比如某些模板实现的时候，在回调实现的时候可以不调用模板中的方法，而是调用其他实现中的某些功能，也就是说功能不再局限在模板和回调实现上了，可以更灵活组织功能。
    3、相对而言，使用继承方式会更简单点，因为父类提供了实现的方法，子类如果不想扩展，那就不用管。
    如果使用回调机制，回调的接口需要把所有可能被扩展的方法都定义进去，这就导致实现的时候，不管要不要拓展，都要实现这个方法，即使是调转模板中已有的实现。
    
 典型应用：排序
    Java的java.util包的Collection类，里面实现了对列表排序的功能，提供了一个静态的sort方法，接受一个列表和一个Comparator接口的实例，实现步骤大致如下：
    1、先把列表转换成对象数组
    2、通过Arrays的sort方法来对数组进行排序，传入Comparator接口的实例
    3、然后再把排好序的数组的数据设置回到原来的列表对象中去
    
 本代码中的排序算模板方法还是策略模式：
    认为策略模式的理由：
    （1）本例的排序实现不同于标准的模板方法模式，使用子类来扩展父类，使用表面上不像模板方法模式。
    （2）排序使用的Comparator的实例，可以看成是不同的算法实现，相当于在切换算法的实现。
    认为模板方法模式的理由：
    （1）模板方法模式的本质是固定算法骨架，虽然使用继承是标准的实现方式，但是通过回调来实现，也不能说不是模板方法。
    （2）从整体程序上看，排序的算法并没有改变，不过是某些步骤是实现发生了变化，也就是说切换的是不同的比较大小的实现，相对于整个排序算法而言，不过是其中一个步骤。
     
 模板模式的优缺点：
    1、实现代码复用
    2、算法骨架不容易升级
    
 模板方法模式的本质：固定算法骨架
 
 对设计原则的体现：
    开闭原则：对新增开放，对修改关闭
    里氏替换原则：子类替换父类，遵循这个原则，保证所有子类实现的是同一个算法模板，并且根据需要切换不同的具体实现。
 
何时选用：
    1、需要固定定义算法骨架，实现一个算法的不变的部分，并把可变的行为留给子类来实现的情况。
    2、各个子类中具有公共行为，应该抽取出来，集中在一个公共类中去实现，从而避免代码重复。
    3、需要控制子类扩展的情况。模板方法模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展。
    




```





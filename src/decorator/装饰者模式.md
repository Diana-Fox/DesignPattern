#装饰者模式
```
定义：
     动态地给对象添加一些额外的职责。就证据给你来说，装饰模式比生成子类更灵活。

装饰者模式的功能：
    能够实现动态的为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。
    当装饰过后，从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。
    变相可以得到另一个好处，就是装饰器的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。
    
对象组合：
    在面向对象设计中，有一条很基本的规则就是”尽量使用组合对象，而不是对象继承“来扩展和复用功能，装饰模式的思考起点就是这个规则。
    
装饰器：
    装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器里面调用被装饰对象的功能，获取相应的值，这其实是一种递归调用。
    装饰器里面不仅仅是可以给被装饰对象增加功能，还可以根据需要选择是否调用被装饰对象的功能，如果不调用被装饰对象的功能，
    那就变成完全重新实现，相当于动态修改了被装饰对象的功能。
    另外一点，个装饰器之间最好是完全独立的功能，不要有以来，这样进行装饰组合的时候，才密钥先后顺序的限制，
    也就是先装饰和后装饰应该是一样的，否则会大大降低装饰器组合的灵活性。

装饰器和组件类的关系：
    装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证他们是同一个类型，并具有同一个外观，
    这样组合完成的装饰才能够递归的调用下去。
    组件类是不知道装饰器的存在的，装饰器给组件添加功能是一种透明的保证，组件类毫不知情。
    需要改变的是外部使用组件类的地方，现在需要使用包装后的类，接口是一样的，但是具体的实现类发生了变化。
    
退化形式：
    如果仅仅是想要添加一个功能，就没有必要再设计装饰器的抽象类了，直接在装饰器里面实现跟组件一样的接口，
    然后实现相应的装饰功能就可以了，但是建议最好还是设计装饰类的抽象类，这样有利于程序的扩展。
    
装饰模式和AOP：
    AOP是面向切面编程，横向考虑数据的结构，AOP动态代理，将功能回贴回去。
    可以使用装饰模式做出类似AOP的效果。

装饰模式的优缺点：
    1、比继承更灵活
    2、更容易复用功能
    3、简化高层定义
    4、会产生很多细粒度对象

装饰模式的本质：动态组合

何时选用：
    1、如果需要在不影响其他对象的情况，以动态、透明的方式给对象添加职责，
    可以选用装饰模式，这几乎是装饰模式的主要功能。
    2、如果不适合用子类来进行扩展的时候，可以考虑使用装饰模式，因为装饰模式是使用“对象组合”的方式。
    所谓不适合用子类拓展的方式，比如扩展功能需要的子类太多，造成子类数目爆炸式增长。
    



```
# 责任链模式

```
定义：
    使多个对象都有机会来处理请求，从而避免请求的发送者和接收者之间的耦合关系。
    将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
    
责任链模式的功能：
    主要用来处理：客户端发出一个请求，有多个对象都有机会来处理这个请求，但是客户端不知道究竟是谁会来处理他的请求。
    这种情况，就需要人请求者和接收者解耦，可以动态的切换和组合接收者。
    在标准的职责链模式中，只有有对象处理了请求，这个请求就到此为止了，不再被传递和处理了。
    如果变形使用责任链，就可以让这个请求继续传递，每个职责对象对这个请求进行一定的功能处理，从而形成一个处理请求的功能链。
    
隐式接收者：
    客户端发出请求的时候，并不知道谁会真正处理他的请求，客户端只知道他提交请求的对一个对象。
    从第一个对象开始，整个职责链里面的对象，要么自己处理请求，要么向下传递。

如何构建链：
    按照实现的地方来说：
        （1）可以实现在客户端，在提交请求前组合链，也就是在使用的时候动态组合链，称为外部链
        （2）可以在Handle里面实现链的组合，算是内部链的一种
        （3）可以在各个职责对象里面，由各个职责对象降低后续的处理对象，这种实现方式要求每个职责对象除了进行业务处理外，
        还必须了解整个业务流程。
    按照数据来源：
        （1）一种就是在程序里面动态组合
        （2）可以通过外部，如数据库来获取组合的数据，职责属于数据库驱动的方式
        （3）还有一种方式是通过配置文件传递尽量，也可以是流程的配置文件。

责任链中，请求不一定会被处理，业务可能没有合适的处理者，请求在责任链里面从头传到尾，
每个处理对象都判断不属于自己处理，最后就没有对象来处理。

处理多种请求：
    如果多种类型的请求是同一流程，但是业务逻辑不同，需要实现。
    简单的实现：
        给接口增加更多的功能，不同请求调用不同的功能。
    通用的请求处理方式：
        简单方式只要增加业务，就需要修改职责接口，不灵活也不符合接口稳定性的要求。
        多请求处理的变化部分：
            一是不同的业务需要传递的业务数据不同
            二是不同的业务请求的方法不同
            三是不同的职责对象处理这些不同的业务请求的业务逻辑不同
        一种简单的方法较好的解决这些问题。首先定义一套通用的框架，用一个通用的请求对象来封装请求传递的参数，
        然后定义一个通用的调用方法，这个方法不去区分具体业务，所有业务都是这个方法，具体的业务区分，
        是在通用的请求对象里面会有一个业务标记，到了职责对象里面，愿意处理就跟原来一样处理，不愿意处理就传递到下一个处理对象即可。
        
功能链：
    一个请求在责任链中传递，每个职责对象负责处理请求的某一方面功能，处理完成后，不是停止，而是继续向下传递请求，
    当请求通过很多职责对象处理过后，功能也就处理完了，把这样的职责链称为功能链。
    
功能链和装饰器对比：
    装饰模式是在已有的功能上增加新的功能，多个装饰器之间会有一定的联系，
    而职责链模式的各个职责对象实现的功能，相互之间是没有关联的，是增加实现属于自己处理的那一份功能。

责任链模式的优缺点：
    1、请求者和接收者松散耦合
    2、动态组合职责
    3、产生很多细粒度对象
    4、不一定被处理

责任链模式的本质：分离职责，动态组合

何时选用责任链模式：
    1、如果有多个对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时动态决定的。
    这种情况可以使用责任链模式，把处理请求的对象实现成为责任对象，然后把透明构成一个责任链，
    当请求在这个链中传递的时候，具体由哪个职责对象来处理，会在运行时动态判断。
    2、如果想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的话，可以使用责任链模式。
    责任链模式实现了请求者和接收者之间的解耦，请求者不需要知道究竟是哪一个接收者对象来处理了请求。
    3、如果相应动态指定处理一个请求的对象集合，可以使用责任链模式，责任链模式能动态的给i偶见责任链，
    也就是动态的来决定到底哪些职责对象来参与到处理请求中来，相当于是动态指定了处理一个请求的职责对象集合。
    




```


 